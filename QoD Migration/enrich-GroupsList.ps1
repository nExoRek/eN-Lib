<#
.SYNOPSIS
    STEP 1 to Office 365 Groups migration in QoD. reads QuestOnDemand export file with G365 list and adds 
    objectID and prepares for target output. 
    LOG ON TO SOURCE TENANT
.DESCRIPTION
    this is 'STEP 1' script in 2-step migration process. what it does:
    - reads the exported list of G365 from Quest On Demand
    - validates if they exist
    - create new output with taget names extended with the defined prefix (group 'source group' will 
      be named 'prefix source group')
    - adds groupID as it will be required for matching
.EXAMPLE
    .\enrich-GroupsList.ps1 -inputCSV sourceTenantgroupsList.csv -targetPrefix 'newCmpny'
    
    checks if all groups from exit and fills in 'source groupID' that will be later used during QoD translation.
    targetPrefix creates new names with given prefix.
.INPUTS
    CSV list exported from Quest On Demand
.OUTPUTS
    enriched CSV to be imported back
.LINK
    https://w-files.pl
.NOTES
    nExoR ::))o-
    version 201204
        last changes
        - 201204 used filter with two conditions to avoid dupes, minor logic change
        - 201130 initialized
#>
#requires -module ExchangeOnlineManagement
[CmdletBinding()]
param (
    #input file generated by Quest On Demand
    [Parameter(mandatory=$true,position=0)]
        [string]$inputCSV,
    #prefix to be added to taget group name and mail nickname
    [Parameter(mandatory=$true,position=1)]
        [string]$targetPrefix,  
    #delimiter
    [Parameter(mandatory=$false,position=2)]
        [string][validateSet(',',';')]$delimiter=','
)
function start-Logging {
    param()

    $scriptRun                          = $PSCmdlet.MyInvocation.MyCommand #(get-variable MyInvocation -scope 1).Value.MyCommand
    [System.IO.fileInfo]$scriptRunPaths = $scriptRun.Path 
    $scriptBaseName                     = $scriptRunPaths.BaseName
    $scriptFolder                       = $scriptRunPaths.Directory.FullName
    $logFolder                          = "$scriptFolder\Logs"

    if(-not (test-path $logFolder) ) {
        try{ 
            New-Item -ItemType Directory -Path $logFolder|Out-Null
            write-host "$LogFolder created."
        } catch {
            $_
            exit -1
        }
    }

    $script:logFile="{0}\_{1}-{2}.log" -f $logFolder,$scriptBaseName,$(Get-Date -Format yyMMddHHmm)
    write-Log "*logging initiated $(get-date)" -silent -skipTimestamp
    write-Log "*script parameters:" -silent -skipTimestamp
    if($script:PSBoundParameters.count -gt 0) {
        write-log $script:PSBoundParameters -silent -skipTimestamp
    } else {
        write-log "<none>" -silent -skipTimestamp
    }
    write-log "***************************************************" -silent -skipTimestamp
}
function write-log {
    param(
        #message to display - can be an object
        [parameter(mandatory=$true,position=0)]
              $message,
        #adds description and colour dependently on message type
        [parameter(mandatory=$false,position=1)]
            [string][validateSet('error','info','warning','ok')]$type,
        #do not output to a screen - logfile only
        [parameter(mandatory=$false,position=2)]
            [switch]$silent,
        # do not show timestamp with the message
        [Parameter(mandatory=$false,position=3)]
            [switch]$skipTimestamp
    )

    #ensure that whatever the type is - array, object.. - it will be output as string, add runtime
    if($null -eq $message) {$message=''}
    $message=($message|out-String).trim() 
    
    try {
        if(-not $skipTimestamp) {
            $message = "$(Get-Date -Format "hh:mm:ss>") "+$type.ToUpper()+": "+$message
        }
        Add-Content -Path $logFile -Value $message
        if(-not $silent) {
            switch($type) {
                'error' {
                    write-host -ForegroundColor Red $message
                }
                'info' {
                    Write-Host -ForegroundColor DarkGray $message
                }
                'warning' {
                    Write-Host -ForegroundColor Yellow $message
                }
                'ok' {
                    Write-Host -ForegroundColor Green $message
                }
                default {
                    Write-Host $message 
                }
            }
        }
    } catch {
        Write-Error 'not able to write to log. suggest to cancel the script run.'
        $_
    }    
}
function load-CSV {
    param(
        [parameter(mandatory=$true,position=0)]
            [string]$inputCSV,
        [parameter(mandatory=$true,position=1)]
            [string[]]$header,
        #expected header
        [parameter(mandatory=$false,position=2)]
            [switch]$headerIsCritical,
        #this flag will exit on load if any column is missing. 
        [parameter(mandatory=$false,position=3)]
            [string]$delimiter=','
    )

    if(-not (test-path $inputCSV) ) {
        write-log "$inputCSV not found." -type error
        exit -1
    }

    try {
        $CSVData=import-csv -path "$inputCSV" -delimiter $delimiter -Encoding UTF8
    } catch {
        Write-log "not able to open $inputCSV. quitting." -type error 
        exit -2
    }

    $csvHeader=$CSVData|get-Member -MemberType NoteProperty|select-object -ExpandProperty Name
    $hmiss=@()
    foreach($el in $header) {
        if($csvHeader -notcontains $el) {
            Write-log """$el"" column missing in imported csv" -type warning
            $hmiss+=$el
        }
    }
    if($hmiss) {
        if($headerIsCritical) {
            Write-log "Wrong CSV header. check delimiter used. quitting." -type error
            exit -2
        }
        $ans=Read-Host -Prompt "some columns are missing. type 'add' to add them, 'c' to continue or anything else to cancel"
        switch($ans) {
            'add' {
                foreach($newCol in $hmiss) {
                    $CSVData|add-member  -MemberType NoteProperty -Name $newCol -value ''
                }
                write-log "header extended" -type info
            }
            'c' {
                write-log "continuing without header change" -type info
            }
            default {
                write-log "cancelled. exitting." -type info
                exit -7
            }
        }
    }
    return $CSVData
}
start-Logging
$exportCSV = "targetG365ToCreate-$(get-date -Format yyMMddHHmm).csv"
$header=@('Group Name','Source MailNickname')
$groupsList=load-CSV -inputCSV $inputCSV -delimiter $delimiter -headerIsCritical -header $header
$groupsList=$groupsList|select *,'target Group Name','target mailNickName',objectID,'target objectID'

foreach($group in $groupsList) {
    $gName=$group.'Group Name'
    write-log "processing ""$gName""..."
    try {
        $filter="displayname -eq ""$gName"" -and alias -eq ""$($group.'source mailNickName')""" 
        $testGroup=Get-UnifiedGroup -Filter $filter
        write-log "$($testGroup.displayName) found." -type info
    } catch {
        $group.'Target Group Name' = '<NOT FOUND>'
        write-log """$gName"" not found" -type warning
        continue
    }
    $group.'target Group Name' = $targetPrefix+' '+$group.'Group Name'
    $group.'target mailNickName' = $targetPrefix+'.'+$group.'Source MailNickname'
    $group.'objectID'=$testGroup.ExternalDirectoryObjectId    
}
$groupsList|export-csv -Delimiter $delimiter -NoTypeInformation $exportCSV -Encoding UTF8
write-log "done. saved in .\$exportCSV" -type ok